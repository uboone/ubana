////////////////////////////////////////////////////////////////////////
// Class:       UsingParticleID
// Plugin Type: analyzer (art v3_00_00)
// File:        UsingParticleID_module.cc
//
// Generated at Fri Jan 18 13:41:59 2019 by Adam Lister using cetskelgen
// from cetlib version v3_04_00.
//
// You can generate the skeleton of a LArSoft module by using the 
// cetskelgen command. This module was generated by using the command:
// 
// cetskelgen analyzer UsingParticleID -e beginJob
//
// This generates an _analyzer_ module with the name 
// UsingParticleID_module.cc. Analyzer modules access information in 
// the artroot file and can print to screen or create ROOT trees. 
// There are also _producer_ modules, which add data products to the
// artroot file, and _filter_ modules, which filter events based on
// criteria defined by the user.
//
// This module will simply access the recob::Track data 
// product, get the associated PID information and store that in a
// root tree
//
// THIS WILL NOT CURRENTLY WORK OUT OF THE BOX, BECASUE THE 
// anab::ParticleID CLASS IS NOT YET STANDARD IN LARSOFT, 
// BUT WILL BE UPDATED IN THE COMING WEEKS
//
////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"


// ART includes
#include "art/Framework/Services/Optional/TFileService.h" // used for ROOT file
#include "canvas/Persistency/Common/FindManyP.h" // used for assns

// LArSoft includes
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/AnalysisBase/ParticleID.h"

// ROOT includes
#include "TTree.h"

class UsingParticleID;


class UsingParticleID : public art::EDAnalyzer {
public:
  explicit UsingParticleID(fhicl::ParameterSet const& p);
  // The compiler-generated destructor is fine for non-base
  // classes without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  UsingParticleID(UsingParticleID const&) = delete;
  UsingParticleID(UsingParticleID&&) = delete;
  UsingParticleID& operator=(UsingParticleID const&) = delete;
  UsingParticleID& operator=(UsingParticleID&&) = delete;

  // Required functions.
  void analyze(art::Event const& e) override;

  // optional function generated by cetskelgen with option
  // '-e beginJob'
  void beginJob() override;

private:

  // initialise services
  art::ServiceHandle< art::TFileService > tfs;

  // variables to be read from fhicl
  std::string fTrackLabel;
  std::string fPIDLabel;

  // and other variables we're going to want
  TTree* out_tree;

  int run;
  int sub_run;
  int event;
  float bragg_p = 0;
  std::vector<float>* bragg_p_v = nullptr;

};


UsingParticleID::UsingParticleID(fhicl::ParameterSet const& p)
  : EDAnalyzer{p}  // ,
  // More initializers here.
{
  // this is how you access variables from fhicl files. The first argument 
  // says "get the fhicl parameter that is called TrackLabel and treat it 
  // as a std::string", the second argument is the default argument in case
  // the fhicl parameter isn't set.
  fTrackLabel = p.get<std::string>("TrackLabel", "pandoraNu::UBXSec");
  fPIDLabel = p.get<std::string>("PIDLabel", "pid::particleid");

}

void UsingParticleID::beginJob()
{

  // the general usage for making objects with tfs is 
  // tfs->make<OBJ>("op1", "op2", "op3" ...), 
  // where the options are the variables needed for the 
  // constructor of the OBJ
  out_tree = tfs->make<TTree>("out_tree"      , "out_tree");
  out_tree->Branch("bragg_p", "std::vector<float>", &bragg_p_v);

}

void UsingParticleID::analyze(art::Event const& e)
{
    run = e.run();
    sub_run = e.subRun();
    event = e.event();

    std::cout << "[TestNewParticleID] Processing event " 
        << run << "." << sub_run << "." << event << std::endl;

    // get a vector of art::Ptrs to a track collection
    art::Handle< std::vector<recob::Track> > track_handle;
    e.getByLabel(fTrackLabel, track_handle);
    std::vector< art::Ptr<recob::Track> > track_ptrvec;
    art::fill_ptr_vector(track_ptrvec, track_handle);

    // setup association
    art::FindManyP< anab::ParticleID > pid_from_track(track_handle, e, fPIDLabel);

    // loop over the tracks
    for (size_t i=0; i < track_ptrvec.size(); i++){

        art::Ptr<recob::Track> this_track = track_ptrvec.at(i);

        // get the pid objects associated to this track
        std::vector< art::Ptr< anab::ParticleID > > pid_collection = pid_from_track.at(this_track.key());

        // loop the pid objects
        // for new files, you'll only have a single pid object, but for running over older
        // files, you may have more than one, so this protects against that
        for (size_t i_pid = 0; i_pid < pid_collection.size(); i_pid++){

            art::Ptr< anab::ParticleID > this_pid = pid_collection.at(i_pid);

            // get the vector of structs from the anab::ParticleID object
            std::vector<anab::sParticleIDAlgScores> AlgScoresVec = this_pid->ParticleIDAlgScores();

            // and now loop and look for the variable you want. 
            // In this example we're going to get the Bragg likelihood for the proton
            for (size_t i_algscore = 0; i_algscore < AlgScoresVec.size(); i_algscore++){

                anab::sParticleIDAlgScores AlgScore = AlgScoresVec.at(i_algscore);

                if (AlgScore.fAlgName == "BraggPeakLLH" && AlgScore.fAssumedPdg == 2212 && AlgScore.fTrackDir == anab::kForward){

                    bragg_p = AlgScore.fValue;
                    std::cout << "Bragg_p = " << bragg_p << std::endl;

                    bragg_p_v->push_back(bragg_p);

                }

            }
        }
    }

    out_tree->Fill();

}

DEFINE_ART_MODULE(UsingParticleID)
