////////////////////////////////////////////////////////////////////////
// Class:       UsingHandlesAna
// Plugin Type: analyzer (art v2_11_03)
// File:        UsingHandlesAna_module.cc
//
// Generated at Wed Sep  5 11:57:10 2018 by Adam Lister using cetskelgen
// from cetlib version v3_03_01.
// 
// You can generate the skeleton of a LArSoft module by using the 
// cetskelgen command. This module was generated by using the command:
// 
// cetskelgen analyzer UsingHandlesAna
//
// This generates an _analyzer_ module with the name 
// UsingHandlesAna_module.cc. Analyzer modules access information in 
// the artroot file and can print to screen or create ROOT trees. 
// There are also _producer_ modules, which add data products to the
// artroot file, and _filter_ modules, which filter events based on
// criteria defined by the user.
//
// This module will simply access the recob::Track data 
// product in a MCC8 simulated data file, and write out some
// track related variables to a simple ROOT tree.
//
// Tested against v07_04_00.
//
////////////////////////////////////////////////////////////////////////

// includes generated by default with cetskelgen
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

// Tracking down includes can be a pain, the way I usually do it is
// by going to the LArSoft doxygen, looking for the relevant .h
// file, and looking at the directory structure on the left.
//
// It's not perfect, but it works most of the time, unless there's
// been any re-organisation of header files.

// ART includes
#include "art/Framework/Services/Optional/TFileService.h" // used for ROOT file

// LArSoft includes
#include "lardataobj/RecoBase/Track.h"

// ROOT includes
#include "TTree.h"

class UsingHandlesAna;


class UsingHandlesAna : public art::EDAnalyzer {

  // By convention, LArSoft modules are completely self contained,
  // meaning that there's no .h file for a _module.cc
  // instead, there's this section at the top for variables and 
  // function definitions.
  //
  // You can force LArSoft to create a separate header files
  // (see cetskelgen --help), but it's ill-advised.

  public:
    explicit UsingHandlesAna(fhicl::ParameterSet const & p);

    UsingHandlesAna(UsingHandlesAna const &) = delete;
    UsingHandlesAna(UsingHandlesAna &&) = delete;
    UsingHandlesAna & operator = (UsingHandlesAna const &) = delete;
    UsingHandlesAna & operator = (UsingHandlesAna &&) = delete;

    void analyze(art::Event const & e) override;

    // this is an optional function, which can be generated automatically
    // using the '-e beginJob' flag with cetskelgen
    void beginJob() override;

    // function to clear out vectors and set dummy variables every event
    void resetVariables();

  private:

    // initialise service handles
    // services basically contain a lot of functions which
    // make your life easier. 
    // There are a few Services you might want to use as an analyzer:
    // * art::TFileService
    //   -- used for saving information to root files (Trees, histograms, etc.)
    // * cheat::BackTracker
    //   -- used to do reco-true matching
    // * geo::Geometry
    //   -- used to access detector geometry information (length, height, 
    //      convert ticks to X position, etc.)
    // * sim::LArG4Parameters
    //   -- used to access information about LAr
    art::ServiceHandle< art::TFileService > tfs;

    // defining private member variables here
    TTree* out_tree;

    int run;
    int sub_run;
    int event;
    // going to set the tree up such that one entry
    // is one event, so anything with multiple
    // objects per event (i.e. tracks) needs a vector
    std::vector<double> track_length_fromhandle_v;
    std::vector<double> track_theta_fromhandle_v;
    std::vector<double> track_phi_fromhandle_v;
    std::vector<double> track_length_fromptrvec_v;
    std::vector<double> track_theta_fromptrvec_v;
    std::vector<double> track_phi_fromptrvec_v;

    // fhicl parameters
    std::string fTrackLabel;

    // other variables
    double track_length;
    double track_theta;
    double track_phi;

};


// This function is the constructor for the module. It's going to be used
// to read in fhicl parameters from the associated fhicl file. 
UsingHandlesAna::UsingHandlesAna(fhicl::ParameterSet const & p)
  :
    EDAnalyzer(p)  // ,
{

  // this is how you access variables from fhicl files. The first argument 
  // says "get the fhicl parameter that is called TrackLabel and treat it 
  // as a std::string", the second argument is the default argument in case
  // the fhicl parameter isn't set.
  fTrackLabel = p.get<std::string>("TrackLabel", "pandoraNu::McRecoStage2");

}

// this function is run once at the beginning of a job, not once per event
// we'll use this to setup the ROOT file
void UsingHandlesAna::beginJob()
{

  // the general usage for making objects with tfs is 
  // tfs->make<OBJ>("op1", "op2", "op3" ...), 
  // where the options are the variables needed for the 
  // constructor of the OBJ
  out_tree = tfs->make<TTree>("out_tree"      , "out_tree");
  out_tree->Branch("track_length_fromhandle_v", "std::vector<double>", &track_length_fromhandle_v);
  out_tree->Branch("track_theta_fromhandle_v" , "std::vector<double>", &track_theta_fromhandle_v);
  out_tree->Branch("track_phi_fromhandle_v"   , "std::vector<double>", &track_phi_fromhandle_v);
  out_tree->Branch("track_length_fromptrvec_v", "std::vector<double>", &track_length_fromptrvec_v);
  out_tree->Branch("track_theta_fromptrvec_v" , "std::vector<double>", &track_theta_fromptrvec_v);
  out_tree->Branch("track_phi_fromptrvec_v"   , "std::vector<double>", &track_phi_fromptrvec_v);

}

// this acts as an event loop, everything inside these brackets are 
// applied to each event
void UsingHandlesAna::analyze(art::Event const & e)
{

  resetVariables();

  // the event itself contains some auxilliary information which we can make use of
  run = e.run();
  sub_run = e.subRun();
  event = e.event();

  std::cout << "Processing event " << run << "." << sub_run << "." << event << std::endl;

  // The standard way to access a data product from an artroot file.
  // How do you know what data products you can access? Check
  // whats in the file! You can do this by running
  // lar -c eventdump.fcl my_input_artroot_file.root
  art::Handle< std::vector<recob::Track> > trackHandle;

  // getByLabel will fill the track handle with a
  // std::vector<recob::Track> with the label defined in
  // fTrackLabel (which comes from the fhicl file)
  e.getByLabel(fTrackLabel, trackHandle);

  // --------------------------------------------------------------------------
  // FIRST METHOD FOR USING THE HANDLE
  // just access it directly
  for (recob::Track const& thisTrack : (*trackHandle)){

    // this way, you already have the recob::Track object and so
    // you can just get the stuff directly
    track_length = thisTrack.Length();
    track_theta  = thisTrack.Theta();
    track_phi    = thisTrack.Phi();

    track_length_fromhandle_v.push_back(track_length);
    track_theta_fromhandle_v.push_back(track_theta);
    track_phi_fromhandle_v.push_back(track_phi);

  }
  // --------------------------------------------------------------------------

  // --------------------------------------------------------------------------
  // SECOND METHOD FOR USING THE HANDLE
  // access via a ptr vector
  std::vector< art::Ptr<recob::Track> > trackPtrVector;
  art::fill_ptr_vector(trackPtrVector, trackHandle);
  for (size_t i = 0; i < trackPtrVector.size(); i++){
    
    art::Ptr<recob::Track> thisTrack = trackPtrVector.at(i);

    // now we have an art::Ptr to an object. The accessor for this is ->, just
    // like a regular pointer, i.e:

    track_length = thisTrack->Length();
    track_theta  = thisTrack->Theta();
    track_phi    = thisTrack->Phi();

    track_length_fromptrvec_v.push_back(track_length);
    track_theta_fromptrvec_v.push_back(track_theta);
    track_phi_fromptrvec_v.push_back(track_phi);

  }

  out_tree->Fill();

}


void UsingHandlesAna::resetVariables()
{

  run = -1;
  sub_run = -1;
  event = -1;

  track_length_fromhandle_v.resize(0);
  track_theta_fromhandle_v.resize(0);
  track_phi_fromhandle_v.resize(0);
  track_length_fromptrvec_v.resize(0);
  track_theta_fromptrvec_v.resize(0);
  track_phi_fromptrvec_v.resize(0);

}


DEFINE_ART_MODULE(UsingHandlesAna)
