////////////////////////////////////////////////////////////////////////
// Class:       UBBasicOpticalAna
// Module Type: analyzer
// File:        UBBasicOpticalAna_module.cc
//
// Generated at Mon Jun  1 04:51:40 2015 by Kazuhiro using artmod
// from cetpkgsupport v1_08_05.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"

#include "lardataobj/RawData/OpDetWaveform.h"
#include "lardataobj/RecoBase/OpHit.h"
#include "lardataobj/RecoBase/OpFlash.h"
#include "OpDetWaveformAna.h"
#include "lardata/DetectorInfoServices/DetectorClocksService.h" // lardata
#include <vector>
#include <string>

#include "larevt/CalibrationDBI/Interface/PmtGainService.h"
#include "larevt/CalibrationDBI/Interface/PmtGainProvider.h"

#include "ubevt/Utilities/PMTRemapProvider.h"
#include "ubevt/Utilities/PMTRemapService.h"

#include "ubevt/Database/LightYieldService.h"
#include "ubevt/Database/LightYieldProvider.h"
#include "ubevt/Database/UbooneLightYieldProvider.h"

class UBBasicOpticalAna;

class UBBasicOpticalAna : public art::EDAnalyzer {
public:
  explicit UBBasicOpticalAna(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  UBBasicOpticalAna(UBBasicOpticalAna const &) = delete;
  UBBasicOpticalAna(UBBasicOpticalAna &&) = delete;
  UBBasicOpticalAna & operator = (UBBasicOpticalAna const &) = delete;
  UBBasicOpticalAna & operator = (UBBasicOpticalAna &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  void beginJob() override;

private:
  std::vector< std::string      > _module_v;    
  std::string                     _hit_producer;
  std::string                     _flash_producer;
  std::vector< bool             > _do_hitana_v;
  std::vector< bool             > _do_wfana_v;
  std::vector< bool             > _store_wf_v;
  std::vector< bool             > _store_ev_wf_v;
  std::vector< bool             > _store_ev_wf_sum_v;
  std::vector<unsigned int      > _nchan;
  std::vector< int              > _chan_mask_v;
  std::vector< ::pmtana::OpDetWaveformAna > _ana_v;
  // Declare member data here.

};


UBBasicOpticalAna::UBBasicOpticalAna(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)  // ,
 // More initializers here.
{
  _module_v           = p.get< std::vector< std::string > > ( "InputModule"      );
  _hit_producer       = p.get< std::string                > ( "HitProducer", ""  );
  _flash_producer     = p.get< std::string                > ( "FlashProducer", "");
  _do_hitana_v        = p.get< std::vector< bool        > > ( "AnaHit"           );
  _do_wfana_v         = p.get< std::vector< bool        > > ( "AnaWaveform"      );
  _store_wf_v         = p.get< std::vector< bool        > > ( "SaveWaveform"     );
  _store_ev_wf_v      = p.get< std::vector< bool        > > ( "SaveEvWaveform"   );
  _store_ev_wf_sum_v  = p.get< std::vector< bool        > > ( "SaveEvWaveformSum");
  _chan_mask_v        = p.get< std::vector<int          > > ( "channelmask"      );
  _nchan              = p.get< std::vector< unsigned int> > ( "nchan"            );
  assert( _module_v.size () == _do_hitana_v.size ()    );
  assert( _module_v.size () == _do_wfana_v.size  ()    );
  assert( _module_v.size () == _store_wf_v.size  ()    );
  assert( _module_v.size () == _store_ev_wf_v.size  () );

  for(auto const& name : _module_v)
    _ana_v.emplace_back( name );
  
}

void UBBasicOpticalAna::beginJob()
{
  art::ServiceHandle<art::TFileService> fs;
  for(size_t i=0; i<_ana_v.size(); ++i) {
   
    
    if( _do_hitana_v [i]     ) _ana_v[i].AnaHit         ( fs->make<TTree> ( "hitana_tree"  , "" ) );
    if( _do_wfana_v  [i]     ) _ana_v[i].AnaWaveform    ( fs->make<TTree> ( "hitwf_tree"   , "" ) );
    if( _store_wf_v  [i]     ) _ana_v[i].SaveWaveform   ( fs->make<TTree> ( TString::Format("wf_tree_%01u",(unsigned int)(i))    , "" ) );
    if( _store_ev_wf_v[i]    ) _ana_v[i].SaveEvWaveform ( fs->make<TTree> ( TString::Format("ev_wf_tree_%01u",(unsigned int)(i)) , "" ), _nchan[i], _store_ev_wf_sum_v[i], _chan_mask_v[i] );
    if (_hit_producer != ""  ) _ana_v[i].SaveEvHit      ( fs->make<TTree> ( "ev_hit_tree"  , "" ) );
    if (_flash_producer != "") _ana_v[i].SaveEvFlash    ( fs->make<TTree> ( "ev_flash_tree", "" ) );

  }    
}

void UBBasicOpticalAna::analyze(art::Event const & e)
{
  auto const* ts = lar::providerFrom<detinfo::DetectorClocksService>();

  auto run = e.run();
  auto sub = e.subRun();
  auto evt = e.event();

  // load gains
  const lariov::PmtGainProvider& gain_provider = art::ServiceHandle<lariov::PmtGainService>()->GetProvider();
  const ::util::PMTRemapProvider &pmtremap_provider = art::ServiceHandle<util::PMTRemapService>()->GetProvider();

  std::vector<double> opch_area_gain_v(32,0.);
  std::vector<double> opch_ampl_gain_v(32,0.);
  for (size_t i=0; i < 32; i++) {
    auto oldch = pmtremap_provider.OriginalOpChannel(i);
    float amplgain = gain_provider.ExtraInfo(oldch%100).GetFloatData("amplitude_gain");
    float areagain = gain_provider.Gain(oldch%100);
    opch_area_gain_v[i] = areagain;
    opch_ampl_gain_v[i] = amplgain;
  }

  // Implementation of required member function here.
  for(size_t i=0; i<_module_v.size(); ++i) {

    _ana_v[i].SetEventInfo(run,sub,evt);

    _ana_v[i].SetEventGain(opch_area_gain_v,opch_ampl_gain_v);
   
    _ana_v[i].TickPeriod(ts->OpticalClock().TickPeriod());
 
    art::Handle< std::vector< raw::OpDetWaveform > > wf_handle;
    e.getByLabel( _module_v[i], wf_handle );

    if (_hit_producer != "") {
      art::Handle< std::vector< recob::OpHit > > hit_handle;
      e.getByLabel( _hit_producer, hit_handle );
      _ana_v[i].AnaEventHit(*hit_handle);
    }// if hit producer is specified

    if (_flash_producer != "") {
      art::Handle< std::vector< recob::OpFlash > > flash_handle;
      e.getByLabel( _flash_producer, flash_handle );
      _ana_v[i].AnaEventFlash(*flash_handle);
    }// if hit producer is specified

    if(!wf_handle.isValid()) continue;

    if (_store_ev_wf_v[i] == true) 
      _ana_v[i].AnaEventWaveform(*wf_handle);

    for(auto const& wf : *wf_handle) {
      if(!wf.size()) continue;
      _ana_v[i].AnaWaveform( wf.ChannelNumber(),
			     wf.TimeStamp() - ts->TriggerTime(),
			     wf );
    }
  }
}

DEFINE_ART_MODULE(UBBasicOpticalAna)
