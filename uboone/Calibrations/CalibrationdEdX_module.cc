////////////////////////////////////////////////////////////////////////
// Class:       CalibrationdEdX
// Module Type: producer
// File:        CalibrationdEdX_module.cc
//
// Generated at Thu Nov 30 15:55:16 2017 by Tingjun Yang using artmod
// from cetpkgsupport v1_13_00.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "lardata/Utilities/AssociationUtil.h"
#include "larreco/Calorimetry/CalorimetryAlg.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/AnalysisBase/Calorimetry.h"

#include "TH2F.h"
#include "TH1F.h"
#include "TFile.h"

#include <memory>

namespace ub {
  class CalibrationdEdX;
}

class ub::CalibrationdEdX : public art::EDProducer {
public:
  explicit CalibrationdEdX(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  CalibrationdEdX(CalibrationdEdX const &) = delete;
  CalibrationdEdX(CalibrationdEdX &&) = delete;
  CalibrationdEdX & operator = (CalibrationdEdX const &) = delete;
  CalibrationdEdX & operator = (CalibrationdEdX &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;

  // Selected optional functions.
  void beginJob() override;

private:

  std::string fTrackModuleLabel;
  std::string fCalorimetryModuleLabel;
  std::string fCalibrationFileName;
  std::vector<std::string> fCorr_YZ;
  std::vector<std::string> fCorr_X;

  calo::CalorimetryAlg caloAlg;

  //histograms for calibration
  std::vector<TH2F*> hCorr_YZ;
  std::vector<TH1F*> hCorr_X;

  double GetYZCorrection(TVector3& xyz, TH2F *his);
  double GetXCorrection(TVector3& xyz, TH1F *his);

};


ub::CalibrationdEdX::CalibrationdEdX(fhicl::ParameterSet const & p)
  : fTrackModuleLabel      (p.get< std::string >("TrackModuleLabel"))
  , fCalorimetryModuleLabel(p.get< std::string >("CalorimetryModuleLabel"))
  , fCalibrationFileName   (p.get< std::string >("CalibrationFileName"))
  , fCorr_YZ               (p.get< std::vector<std::string> >("Corr_YZ"))
  , fCorr_X                (p.get< std::vector<std::string> >("Corr_X"))
  , caloAlg(p.get< fhicl::ParameterSet >("CaloAlg"))
{
  // Call appropriate produces<>() functions here.
  if (fCorr_YZ.size()!=3 || fCorr_X.size()!=3){
    throw art::Exception(art::errors::Configuration)
      <<"Size of Corr_YZ and Corr_X need to be 3.";
  }

  //create calorimetry product and its association with track
  produces< std::vector<anab::Calorimetry>              >();
  produces< art::Assns<recob::Track, anab::Calorimetry> >();

}

void ub::CalibrationdEdX::produce(art::Event & evt)
{

  //create anab::Calorimetry objects and make association with recob::Track
  std::unique_ptr< std::vector<anab::Calorimetry> > calorimetrycol(new std::vector<anab::Calorimetry>);
  std::unique_ptr< art::Assns<recob::Track, anab::Calorimetry> > assn(new art::Assns<recob::Track, anab::Calorimetry>);

  //get existing track/calorimetry objects
  art::Handle< std::vector<recob::Track> > trackListHandle;
  evt.getByLabel(fTrackModuleLabel,trackListHandle);

  std::vector<art::Ptr<recob::Track> > tracklist;
  art::fill_ptr_vector(tracklist, trackListHandle);

  art::FindManyP<anab::Calorimetry> fmcal(trackListHandle, evt, fCalorimetryModuleLabel);

  if (!fmcal.isValid()){
    throw art::Exception(art::errors::ProductNotFound)
      <<"Could not get assocated Calorimetry objects";
  }

  for (size_t trkIter = 0; trkIter < tracklist.size(); ++trkIter){   
    for (size_t i = 0; i<fmcal.at(trkIter).size(); ++i){
      auto & calo = fmcal.at(trkIter)[i];
      
      if (!(calo->dEdx()).size()){
        //empty calorimetry product, just copy it
        calorimetrycol->push_back(*calo);
        util::CreateAssn(*this, evt, *calorimetrycol, tracklist[trkIter], *assn);
      }
      else{
        //start calibrating dQdx

        //get original calorimetry information
        double                Kin_En     = calo->KineticEnergy();
        std::vector<double>   vdEdx      = calo->dEdx();
        std::vector<double>   vdQdx      = calo->dQdx();
        std::vector<double>   vresRange  = calo->ResidualRange();
        std::vector<double>   deadwire   = calo->DeadWireResRC();
        double                Trk_Length = calo->Range();
        std::vector<double>   fpitch     = calo->TrkPitchVec();
        std::vector<TVector3> vXYZ       = calo->XYZ();
        geo::PlaneID          planeID    = calo->PlaneID();

        //make sure the vectors are of the same size
        if (vdEdx.size()!=vXYZ.size()||
            vdQdx.size()!=vXYZ.size()||
            vresRange.size()!=vXYZ.size()||
            fpitch.size()!=vXYZ.size()){
          throw art::Exception(art::errors::Configuration)
      <<"Vector sizes mismatch for vdEdx, vdQdx, vresRange, fpitch, vXYZ";
        }

        //make sure the planeID is reasonable
        if (!planeID.isValid){
          throw art::Exception(art::errors::Configuration)
      <<"planeID is invalid";
        }
        if (planeID.Plane<0 || planeID.Plane>2){
          throw art::Exception(art::errors::Configuration)
            <<"plane is invalid "<<planeID.Plane;
        }
        for (size_t j = 0; j<vdQdx.size(); ++j){
          double yzcorrection = GetYZCorrection(vXYZ[j], hCorr_YZ[planeID.Plane]);
          double xcorrection = GetXCorrection(vXYZ[j], hCorr_X[planeID.Plane]);
          vdQdx[j] = yzcorrection*xcorrection*vdQdx[j];
        }
        //save new calorimetry information 
        calorimetrycol->push_back(anab::Calorimetry(Kin_En,
                                                    vdEdx,
                                                    vdQdx,
                                                    vresRange,
                                                    deadwire,
                                                    Trk_Length,
                                                    fpitch,
                                                    vXYZ,
                                                    planeID));
        util::CreateAssn(*this, evt, *calorimetrycol, tracklist[trkIter], *assn);
      }//calorimetry object not empty
    }//loop over calorimetry objects
  }//loop over tracks

  evt.put(std::move(calorimetrycol));
  evt.put(std::move(assn));

  return;
}

void ub::CalibrationdEdX::beginJob()
{
  // Implementation of optional member function here.

  // Open root file with YZ and X corrections
  TFile f(fCalibrationFileName.c_str());

  // Read in correction histograms
  for (size_t i = 0; i<fCorr_YZ.size(); ++i){
    hCorr_YZ.push_back((TH2F*)f.Get(fCorr_YZ[i].c_str()));
    if (!hCorr_YZ.back()){
      throw art::Exception(art::errors::Configuration)
        <<"Could not find histogram "<<fCorr_YZ[i]<<" in "<<fCalibrationFileName;
    }
    hCorr_X.push_back((TH1F*)f.Get(fCorr_X[i].c_str()));
    if (!hCorr_X.back()){
      throw art::Exception(art::errors::Configuration)
        <<"Could not find histogram "<<fCorr_X[i]<<" in "<<fCalibrationFileName;
    }
  }
}
                            
double ub::CalibrationdEdX::GetYZCorrection(TVector3& xyz, TH2F *his){

  if (!his){
    throw art::Exception(art::errors::Configuration)
      <<"Histogram is empty";
  }
  int biny = his->GetXaxis()->FindBin(xyz[1]);
  if (biny == 0) biny = 1;
  if (biny == his->GetNbinsX()+1) biny = his->GetNbinsX();

  int binz = his->GetYaxis()->FindBin(xyz[2]);
  if (binz == 0) binz = 1;
  if (binz == his->GetNbinsY()+1) binz = his->GetNbinsY();

  double corr = his->GetBinContent(biny, binz);

  if (corr) return corr;

  //looking at neighboring bins
  for (int i = biny + 1; i <= his->GetNbinsX(); ++i){
    if (his->GetBinContent(i, binz)){
      return his->GetBinContent(i, binz);
    }
  }
  
  for (int i = biny - 1; i >= 1; --i){
    if (his->GetBinContent(i, binz)){
      return his->GetBinContent(i, binz);
    }
  }
  
  for (int i = binz + 1; i <= his->GetNbinsY(); ++i){
    if (his->GetBinContent(biny, i)){
      return his->GetBinContent(biny, i);
    }
  }
  
  for (int i = binz - 1; i >= 1; --i){
    if (his->GetBinContent(biny, i)){
      return his->GetBinContent(biny, i);
    }
  }
  
  //no nonzero correction found? just return 1
  return 1.;
  
}

double ub::CalibrationdEdX::GetXCorrection(TVector3& xyz, TH1F *his){

  if (!his){
    throw art::Exception(art::errors::Configuration)
      <<"Histogram is empty";
  }

  int bin = his->GetXaxis()->FindBin(xyz[0]);
  if (bin == 0) bin = 1;
  if (bin == his->GetNbinsX()+1) bin = his->GetNbinsX();

  return his->GetBinContent(bin);

}

DEFINE_ART_MODULE(ub::CalibrationdEdX)
